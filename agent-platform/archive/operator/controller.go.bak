// Renamed to controller.go.bak to avoid controller-gen errors

package main
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "os"
    "bytes"
    "k8s.io/apimachinery/pkg/runtime/schema"
    "sigs.k8s.io/controller-runtime/pkg/log/zap"
    appsv1 "k8s.io/api/apps/v1"
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/apimachinery/pkg/runtime"
    clientgoscheme "k8s.io/client-go/kubernetes/scheme"
    "k8s.io/client-go/rest"
    "k8s.io/client-go/tools/clientcmd"
    "sigs.k8s.io/controller-runtime/pkg/client"
    ctrl "sigs.k8s.io/controller-runtime"
    "sigs.k8s.io/controller-runtime/pkg/reconcile"
    "sigs.k8s.io/controller-runtime/pkg/log"
)

// Register the correct CRD group and version
var GroupVersion = schema.GroupVersion{Group: "agentplatform.example.com", Version: "v1"}

// MultiAgentFlow CRD struct for controller-runtime
// Add runtime.Object interface

// MultiAgentFlowSpec defines the desired state of MultiAgentFlow
type MultiAgentFlowSpec struct {
	MCP        []map[string]interface{} `json:"mcp,omitempty"`
	LLMS       []map[string]interface{} `json:"llms,omitempty"`
	Logging    map[string]interface{}   `json:"logging,omitempty"`
	Agents     []map[string]interface{} `json:"agents,omitempty"`
	Connections []map[string]interface{} `json:"connections,omitempty"`
}

// MultiAgentFlow is the Schema for the multiagentflows API
type MultiAgentFlow struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MultiAgentFlowSpec `json:"spec,omitempty"`
}


// DeepCopy creates a deep copy of MultiAgentFlow
func (in *MultiAgentFlow) DeepCopy() *MultiAgentFlow {
	if in == nil {
		 return nil
	}
	out := new(MultiAgentFlow)
	*out = *in
	out.ObjectMeta = *in.ObjectMeta.DeepCopy()
	// If you have complex fields in Spec, deep copy them here as needed
	return out
}

func (in *MultiAgentFlow) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

// MultiAgentFlowList contains a list of MultiAgentFlow
type MultiAgentFlowList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MultiAgentFlow `json:"items"`
}

func (in *MultiAgentFlowList) DeepCopyObject() runtime.Object {
	if in == nil { return nil }
	out := new(MultiAgentFlowList)
	*out = *in
	out.ListMeta = *in.ListMeta.DeepCopy()
       out.Items = make([]MultiAgentFlow, len(in.Items))
       for i := range in.Items {
	       out.Items[i] = *in.Items[i].DeepCopy()
       }
	return out
}

type Reconciler struct {
	client client.Client
}

// int32Ptr returns a pointer to an int32 value
func int32Ptr(i int32) *int32 { return &i }

func (r *Reconciler) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) {
	logger := log.FromContext(ctx)
	logger.Info("Reconciling MultiAgentFlow", "name", req.Name)

	// Fetch the MultiAgentFlow CR
	var cr MultiAgentFlow
	if err := r.client.Get(ctx, req.NamespacedName, &cr); err != nil {
		logger.Error(err, "unable to fetch MultiAgentFlow")
		return reconcile.Result{}, client.IgnoreNotFound(err)
	}

       // Ensure Python server Deployment exists in the same namespace as the CR
       depName := "python-server"
       dep := &appsv1.Deployment{
	       ObjectMeta: metav1.ObjectMeta{
		       Name:      depName,
		       Namespace: req.Namespace,
		       Labels: map[string]string{
			       "app": depName,
		       },
	       },
	       Spec: appsv1.DeploymentSpec{
		       Replicas: int32Ptr(1),
		       Selector: &metav1.LabelSelector{
			       MatchLabels: map[string]string{"app": depName},
		       },
		       Template: corev1.PodTemplateSpec{
			       ObjectMeta: metav1.ObjectMeta{
				       Labels: map[string]string{"app": depName},
			       },
			       Spec: corev1.PodSpec{
				       Containers: []corev1.Container{{
					       Name:  depName,
					       Image: "agent-platform-python-server:latest",
					       ImagePullPolicy: corev1.PullIfNotPresent,
					       Ports: []corev1.ContainerPort{{
						       ContainerPort: 5000,
					       }},
					       Env: []corev1.EnvVar{{
						       Name:  "FLASK_ENV",
						       Value: "production",
					       }},
				       }},
			       },
		       },
	       },
       }

       // Try to get the Deployment
       found := &appsv1.Deployment{}
       err := r.client.Get(ctx, client.ObjectKey{Name: depName, Namespace: req.Namespace}, found)
       if err != nil {
	       if client.IgnoreNotFound(err) == nil {
		       // Not found, create it
		       if err := r.client.Create(ctx, dep); err != nil {
			       logger.Error(err, "unable to create Python server Deployment")
			       return reconcile.Result{}, err
		       }
		       logger.Info("Created Python server Deployment")
	       } else {
		       logger.Error(err, "unable to get Python server Deployment")
		       return reconcile.Result{}, err
	       }
       } else {
	       // Found, update if spec differs (simple replace)
	       dep.ResourceVersion = found.ResourceVersion
	       if err := r.client.Update(ctx, dep); err != nil {
		       logger.Error(err, "unable to update Python server Deployment")
		       return reconcile.Result{}, err
	       }
	       logger.Info("Updated Python server Deployment")
       }

       // (Optional) Send the spec to the Python server as before
       specBytes, err := json.Marshal(cr.Spec)
       if err != nil {
	       logger.Error(err, "unable to marshal spec")
	       return reconcile.Result{}, err
       }
       pythonServerURL := "http://python-server:8080/deploy"
       resp, err := http.Post(pythonServerURL, "application/json", bytes.NewBuffer(specBytes))
       if err != nil {
	       logger.Error(err, "unable to POST to Python server")
	       return reconcile.Result{}, err
       }
       defer resp.Body.Close()
       logger.Info("Posted spec to Python server", "status", resp.Status)

	return reconcile.Result{}, nil
}

func main() {
	// Enable controller-runtime logging
	log.SetLogger(zap.New(zap.UseDevMode(true)))
	fmt.Println("Starting MultiAgentFlow controller...")
	scheme := clientgoscheme.Scheme
	scheme.AddKnownTypes(GroupVersion, &MultiAgentFlow{}, &MultiAgentFlowList{})

	var cfg *rest.Config
	var err error
	cfg, err = rest.InClusterConfig()
	if err != nil {
		fmt.Println("Falling back to kubeconfig...")
		kubeconfigPath := os.Getenv("KUBECONFIG")
		if kubeconfigPath == "" {
			kubeconfigPath = os.ExpandEnv("$HOME/.kube/config")
		}
		cfg, err = clientcmd.BuildConfigFromFlags("", kubeconfigPath)
		if err != nil {
			fmt.Println("Could not get Kubernetes config")
			os.Exit(1)
		}
	}

	mgr, err := ctrl.NewManager(cfg, ctrl.Options{Scheme: scheme})
	if err != nil {
		fmt.Println("Unable to start manager", err)
		os.Exit(1)
	}

	reconciler := &Reconciler{client: mgr.GetClient()}
	err = ctrl.NewControllerManagedBy(mgr).
		For(&MultiAgentFlow{}).
		Complete(reconciler)
	if err != nil {
		fmt.Println("Unable to set up controller", err)
		os.Exit(1)
	}

	fmt.Println("Controller is running. Apply a MultiAgentFlow CR to send config to Python server.")
	if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {
		fmt.Println("Problem running manager", err)
		os.Exit(1)
	}
}
